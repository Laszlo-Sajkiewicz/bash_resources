#!/bin/bash

#sets up dot bash files in your home directory
DEBUG=0
DRY_RUN=0

homedir=${homedir:-${HOME:?"HOME environment var must be set!!!!"}}

programs_to_chec_for=(fortune, uname, uptime)

quick_checks() {

    local oops_count=0
    for program in ${programs_to_check_for[@]}; do
        ${program} >& /dev/null
        [ $? != 0 ] && ((oops_count++)) && echo "Couldn't find ${program}"
    done
    if ((oops_count > 0)); then
        You may want to install the missed programs with...
        if uname -a | grep -q Darwin; then
            echo "MacPorts: https://www.macports.org/install.php"
            echo "> port install <program>"
        else
            echo "Please install the missed programs for optimum use"
        fi
}

# Utility "private" method
_readlinkf() {
    # This is a portable implementation of GNU's "readlink -f" in
    # bash/zsh, following symlinks recursively until they end in a
    # file, and will print the full dereferenced path of the specified
    # file even if the file isn't a symlink.
    #
    # Loop detection exists, but only as an abort after passing a
    # maximum length.

    local start_dir=$(pwd)
    local file=${1}
    cd $(dirname ${file})
    file=$(basename ${file})

    # Iterate down symlinks.  If we exceed a maximum number symlinks, assume that
    # we're looped and die horribly.
    local maxlinks=20
    local count=0
    local current_dir
    while [ -L "${file}" ] ; do
        file=$(readlink ${file})
        cd $(dirname ${file})
        file=$(basename ${file})
        ((count++))
        if (( count > maxlinks )) ; then
            current_dir=$(pwd -P)
            echo "CRITICAL FAILURE[4]: symlink loop detected on ${current_dir}/${file}"
            cd ${start_dir}
            exit ${count}
        fi
    done
    current_dir=$(pwd -P)
    echo "${current_dir}/${file}"
    cd ${start_dir}
}

setup_dot_bash_files() {
    [ ! -e .git ] && echo "Sorry this is not a git repo" && exit 1
    
    for dot_file in $(ls -a | grep bash); do
        echo -n "setting up $dot_file... "
        #check if the file exists already
        if [ "$(_readlinkf ${dot_file})" == "$(_readlinkf ${homedir}/${dot_file} | tail -n 1)" ]; then
            echo "[OK] (nothing to do already linked)"
        else
            ((DEBUG|DRY_RUN)) && echo "[ -e ${homedir}/${dot_file} ]  && mv -v ${homedir}/${dot_file}{,.bak}"
            ((! DRY_RUN)) && [ -e ${homedir}/${dot_file} ] && mv -v ${homedir}/${dot_file}{,.bak}
            ((DEBUG||DRY_RUN)) && echo "ln -s $(_readlinkf ${dot_file}) ${homedir}/${dot_file}"
            if ((! DRY_RUN)); then
                ln -s $(_readlinkf ${dot_file}) ${homedir}/${dot_file}
                [ $? != 0 ] && echo "ERROR: problem linking ${dot_file}" || echo " linked file... [OK] "
            fi
        fi
    done
}

revert_homedir() {
    [ ! -e .git ] && echo "Sorry this is not a git repo" && exit 1
}

#TODO - implement revert_homedir function
#TODO - write arg code to trigger revert if necessary
quick_checks
setup_dot_bash_files $@
